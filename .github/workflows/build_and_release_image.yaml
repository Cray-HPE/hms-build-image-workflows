name: Build and Publish Docker images
on:
  workflow_call:
    inputs:
      runs-on:
        description: The type of machine to run the job on.
        type: string
        required: false
        default: ubuntu-latest
      
      docker-registry:
        description: Registry to publish container images to
        type: string
        default: artifactory.algol60.net
        required: false
      image-name:
        description: Container image name. For example, cray-firmware-action
        type: string
        required: true
      docker-build-context:
        description: Build's context is the set of files located in the specified PATH.
        type: string
        default: "."
        required: false
      docker-build-file:
        description: Path to the Dockerfile.
        type: string
        default: Dockerfile
        required: false

      enable-latest-tag:
        description: Enable the latest tag for stable builds. Choose from true or false
        type: string
        default: false
        required: false

      snyk-severity:
        description: |
          Only report vulnerabilities of provided level or higher.
          Choose from: low, medium, high, or critical
        type: string
        default: high
        required: false

      # TODO It doesn't look like continue-on-error can be templated
      # snyk-continue-on-error:
      #   description: Control where snyk should continue on if an error/vulnerability is found. Choose from true or false
      #   type: string
      #   default: false
      #   required: false
      
      trivy-enable:
        description: Enable or disable the Trivy Vulnerability scanner. Choose from true or false
        type: string
        default: false
        required: false
      trivy-exit-code:
        description: Exit code when vulnerabilities were found
        type: string
        default: 0
        required: false
      trivy-severity:
        description: Severities of vulnerabilities to be displayed
        type: string
        default: CRITICAL,HIGH
        required: false

      enable-pr-comment:
        description: Control whether the update-pr-with-artifacts job runs on PR builds. Choose from true or false
        type: string
        default: true
        required: false
      pr-comment-template-path:
        description: File path for the template for the PR comment template. It is expected the that the comment template is present in the application repo, not this one.
        type: string
        default: .github/build-image-comment-template.md
        required: false
    
    secrets:
      artifactory-username:
        description: Artifactory username used for docker pushes
        required: true
      artifactory-token:
        description: Artifactory token from the given user
        required: true
      
      snyk-token:
        description: Snyk authorization token
        required: true
      
      cosign-gcp-project-id:
        description: Project ID in GCP for cosign
        required: true
      cosign-gcp-sa-key:
        description: Service account key in GCP for cosign
        required: true
      cosign-key:
        description: cosign key
        required: true
jobs:
  build_and_release:
    name: Build and Publish Docker images
    runs-on: ${{ inputs.runs-on }}
    outputs:
      stable-string: ${{ steps.image-meta.outputs.stable-string }}
      image: ${{ steps.image-meta.outputs.image }}
      image-tag: ${{ steps.image-meta.outputs.tag }}
      image-repository: ${{ steps.image-meta.outputs.repository }}
      all-image-tags: ${{ steps.meta.outputs.tags }}
    steps:
    #
    # Setup build environment
    #
    - name: Checkout
      uses: actions/checkout@v2
      with:
        fetch-depth: 0
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v1

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Login to algol60 Container Registry
      uses: docker/login-action@v1
      with:
        registry: ${{ inputs.docker-registry }}
        username: ${{ secrets.artifactory-username }}
        password: ${{ secrets.artifactory-token }}

    #
    # Build, scan, push, and sign container image
    #
    - name: Generate build metadata
      uses: Cray-HPE/hms-build-metadata-action/generate-build-metadata@v1
      id: build-metadata
      with:
        stable-strategy: tag

    # TODO if this is a stable build from a git tag, lets check that git tag matches.

    - name: Determine container image name and tag
      id: image-meta
      run: |
        # Retrieve the version from the .version file, and append the build metadata to it.
        STABLE_STRING=${{ fromJSON(steps.build-metadata.outputs.is-stable) && 'stable' || 'unstable' }}
        REPOSITORY=${{ inputs.docker-registry }}/csm-docker/$STABLE_STRING/${{ inputs.image-name }}
        DOT_VERSION=$(cat .version)
        TAG=$DOT_VERSION${{ steps.build-metadata.outputs.docker }}
        IMAGE=$REPOSITORY:$TAG

        echo "Stable string: $STABLE_STRING"
        echo "Container image repository: $REPOSITORY"
        echo "Container image tag: $TAG"
        echo "Container image: $IMAGE"
        echo ".version: $DOT_VERSION"

        echo "::set-output name=stable-string::$STABLE_STRING"
        echo "::set-output name=repository::$REPOSITORY"
        echo "::set-output name=tag::$TAG"
        echo "::set-output name=image::$IMAGE"
        echo "::set-output name=dot-version::$DOT_VERSION"

    - name: Docker metadata
      id: meta
      uses: docker/metadata-action@v3
      with:
        images: ${{ steps.image-meta.outputs.repository }}
        labels: |
          org.opencontainers.image.vendor=Hewlett Packard Enterprise Development LP
        flavor: |
          latest=${{ inputs.enable-latest-tag }}
        tags: |
          type=schedule
          type=raw,value=${{ steps.image-meta.outputs.tag }}
          type=semver,pattern={{version}},value=${{ steps.image-meta.outputs.tag }}
        # Note, the {{major}}, {{major}}.{{minor}} patterns only work on git tags

    - name: Build image
      uses: docker/build-push-action@v2
      id: docker-build
      with:
        context: ${{ inputs.docker-build-context }}
        file: ${{ inputs.docker-build-file }}
        load: true
        push: false
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Current images
      shell: bash
      run: docker images

    - name: Run Snyk to check Docker images for vulnerabilities
      uses: snyk/actions/docker@master
      # TODO Revisit out how we want to handle failing synk scans. I like the idea of snyk scan failing a unstable build as that will force us to deal with it.
      # TODO It doesn't look like continue-on-error can be templated
      # continue-on-error: ${{ !fromJSON(steps.build-metadata.outputs.is-stable) }}  # If stable build force build failure, for unstable push on.
      # continue-on-error: ${{ fromJSON(inputs.snyk-continue-on-error) }}
      # continue-on-error: ${{ inputs.snyk-continue-on-error == 'true' }}
      env:
        SNYK_TOKEN: ${{ secrets.snyk-token }}
      with:
        image: ${{ steps.image-meta.outputs.image }}
        args: --severity-threshold=${{ inputs.snyk-severity }} --skip-unresolved=true

    # TODO need a policy on how to use Trivy results
    - name: Run Trivy vulnerability scanner 
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: image
        exit-code: ${{ inputs.trivy-exit-code }}
        image-ref: ${{ steps.image-meta.outputs.image }}
        severity: ${{ inputs.trivy-severity }}
        hide-progress: false
      if: ${{ fromJSON(inputs.trivy-enable) }}

    - name: Push image(s)
      shell: bash
      env:
        IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
      run: |
        set -eu
        for IMAGE_TAG in $IMAGE_TAGS; do
          echo "Pushing image: $IMAGE_TAG"
          docker push "$IMAGE_TAG"
        done

    - name: Sign an image in artifactory
      uses: Cray-HPE/.github/actions/csm-sign-image@v2.0-csm-sign-image
      with:
        cosign-gcp-project-id: ${{ secrets.cosign-gcp-project-id }}
        cosign-gcp-sa-key: ${{ secrets.cosign-gcp-sa-key }}
        cosign-key: ${{ secrets.cosign-key }}
        registry: ${{ inputs.docker-registry }}
        registry-username: ${{ secrets.artifactory-username }}
        registry-password: ${{ secrets.artifactory-token }}
        github-sha: ${{ github.sha }}
        image: ${{ steps.image-meta.outputs.image }}

    - name: Generate, Attach, and Sign container image SBOM
      uses: Cray-HPE/.github/actions/csm-generate-attach-sign-sbom@v1.0-csm-generate-attach-sign-sbom
      id: sbom
      with:
        cosign-gcp-project-id: ${{ secrets.cosign-gcp-project-id }}
        cosign-gcp-sa-key: ${{ secrets.cosign-gcp-sa-key }}
        cosign-key: ${{ secrets.cosign-key }}
        registry: ${{ inputs.docker-registry }}
        registry-username: ${{ secrets.artifactory-username }}
        registry-password: ${{ secrets.artifactory-token }}
        github-sha: ${{ github.sha }}
        image: ${{ steps.image-meta.outputs.image }}

    - name: Artifact download links
      env:
        IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
        IMAGE: ${{ steps.image-meta.outputs.image }}
      run: |
        echo "Container images"
        for IMAGE_TAG in $IMAGE_TAGS; do
          echo "  Pull command: docker pull $IMAGE_TAG"
        done
        echo "Download SBOM: cosign download sbom $IMAGE > container_image.spdx"

  update-pr-with-artifacts:
    name: Update PR comment with artifacts
    runs-on: ${{ inputs.runs-on }}
    if: ${{ fromJSON(inputs.enable-pr-comment) && github.event_name == 'pull_request' }}
    needs:
      - build_and_release
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
      
      - name: Create comment vars
        id: comment-vars
        run: |
          echo "::set-output name=repo_name::$(echo "${GITHUB_ACTOR}_${GITHUB_REPOSITORY}_${GITHUB_REF_NAME}" | sed 's|/|_|g')"

      - name: Find Comment
        uses: peter-evans/find-comment@v1
        id: fc
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: ${{ needs.build_and_release.outputs.image-repository }}

      - name: Render template
        id: template
        uses: chuhlomin/render-template@v1
        with:
          # It is expected the that the build-image-comment-template.md is present in the application repo, not this one.
          template: ${{ inputs.pr-comment-template-path }}
          # Note the vars below cannot have dashes '-' in them
          vars: |
            image: ${{ needs.build_and_release.outputs.image }}
            imageTag: ${{ needs.build_and_release.outputs.image-tag }}
            imageRepository: ${{ needs.build_and_release.outputs.image-repository }} 
            imageName: ${{ inputs.image-name }}
            stableString: ${{ needs.build_and_release.outputs.stable-string }}
            PRHeadSha: ${{ github.event.pull_request.head.sha }}

      - name: Create comment
        if: steps.fc.outputs.comment-id == ''
        uses: peter-evans/create-or-update-comment@v1
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: ${{ steps.template.outputs.result }}
          reactions: rocket

      - name: Update comment
        if: steps.fc.outputs.comment-id != ''
        uses: peter-evans/create-or-update-comment@v1
        with:
          comment-id: ${{ steps.fc.outputs.comment-id }}
          body: ${{ steps.template.outputs.result }}
          edit-mode: replace

#todos
#1 what do we do if snyk fails? an artifact has already been published?
#  - Break apart the docker/build-push-actions. 1. Build the image, 2. Scan the image, 3. Push the image
#2 need to parameterize repo and semver
#3 need to clarify the build tags we want
#  - Stable builds have 1.1.1, 1.1, 1
#  - Unstable builds have 1.1.1-12345.123
#4 need to clarify how use gets notified if synk encounters an error; does it just keep on going? or does it stop?
#  - Ryan S: My opinion is that it should cause the build to fail and not push any images.
#5 STRETCH objective : integrate SBOM
#6 where are we sending the snyk/trivy reports? Thinking about sending it to its OWN file in artifactory named: sha-digest.snky ; need to look at how the     - name: Publish Helm charts uploads and modify?